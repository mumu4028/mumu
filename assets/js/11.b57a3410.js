(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{285:function(t,v,_){"use strict";_.r(v);var p=_(14),a=Object(p.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"vue2组件间通讯"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue2组件间通讯"}},[t._v("#")]),t._v(" vue2组件间通讯")]),t._v(" "),v("h3",{attrs:{id:"_1、准备工作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、准备工作"}},[t._v("#")]),t._v(" 1、准备工作")]),t._v(" "),v("p",[t._v("​\t1、把定义好的communication组件注册到我们的前台项目当中")]),t._v(" "),v("p",[t._v("​\t2、修改路由配置")]),t._v(" "),v("p",[t._v("​\t3、注册element-ui的button组件")]),t._v(" "),v("h3",{attrs:{id:"_2、组件间通信props-一"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、组件间通信props-一"}},[t._v("#")]),t._v(" 2、组件间通信props(一)")]),t._v(" "),v("p",[t._v("​\tprops   子组件声明接收属性三种写法  数组： [‘todos’]  对象：{ todos:Array}  对象的复杂写法：{ todos:{type:Array,default:[]}}")]),t._v(" "),v("p",[t._v("​\t组件之间的通信方式")]),t._v(" "),v("p",[t._v("​\t父子之间")]),t._v(" "),v("p",[t._v("​\t父可以给子传递 非函数和函数")]),t._v(" "),v("p",[t._v("​\t传非函数数据 就是父向子")]),t._v(" "),v("p",[t._v("​\t传函数数据  本质是父想要子的数据，子向父")]),t._v(" "),v("p",[t._v("​\t特殊：")]),t._v(" "),v("p",[t._v("​\t\t路由配置 props（三种）  路由组件之间没有标签，但是可以把参数通过路由映射为属性\n​\t\t1、布尔值  true  把路径params参数映射为要显示的组件内属性")]),t._v(" "),v("p",[t._v("​\t\t2、对象  {name:'赵丽颖'}  只能映射传递额外的静态的数据 一般不用")]),t._v(" "),v("p",[t._v("​\t\t3、函数\t props:(route) =>{}  自己手动映射params参数和query参数 成为要显示的组件内属性")]),t._v(" "),v("p",[t._v("​")]),t._v(" "),v("p",[t._v("​\t\t如果不用props，那么组件内要用数据必须要写成 this.$route.params.xxx  this.$route.query.xxx")]),t._v(" "),v("h3",{attrs:{id:"_3、组件间通信自定义事件-二"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、组件间通信自定义事件-二"}},[t._v("#")]),t._v(" 3、组件间通信自定义事件（二）")]),t._v(" "),v("h5",{attrs:{id:"自定义事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自定义事件"}},[t._v("#")]),t._v(" 自定义事件")]),t._v(" "),v("p",[t._v("​\t\t组件通信的一种方式")]),t._v(" "),v("p",[t._v("​\t适用场合：")]),t._v(" "),v("p",[t._v("​\t\t子向父传递数据")]),t._v(" "),v("p",[t._v("​\t怎么做")]),t._v(" "),v("p",[t._v("​\t\t在父组件当中给子组件标签绑定自定义事件，事件回调留在父组件当中")]),t._v(" "),v("p",[t._v("​\t\t在子组件当中触发它自己身上绑定的自定义事件，触发事件调用回调函数可以通过实参传递")]),t._v(" "),v("p",[t._v("​\t原生dom事件")]),t._v(" "),v("p",[t._v("​\t\t事件类型  回调函数  谁调用  默认传递的实参是什么")]),t._v(" "),v("p",[t._v("​\t\t1、事件类型    固定的几个")]),t._v(" "),v("p",[t._v("​\t\t2、回调函数    自己去定义的")]),t._v(" "),v("p",[t._v("​\t\t3、触发（分发、触发事件）了谁调用  系统调用  浏览器去调用")]),t._v(" "),v("p",[t._v("​\t\t4、event事件对象  （浏览器在调用回调函数的时候，会把当前这一次触发事件相关的所有信息封装成一个对象")]),t._v(" "),v("p",[t._v("​\t\t传递给回调函数的第一个形参）")]),t._v(" "),v("p",[t._v("​\t\tbox.onclick = function(event){")]),t._v(" "),v("p",[t._v("​\t\t}")]),t._v(" "),v("h5",{attrs:{id:"自定义事件-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自定义事件-2"}},[t._v("#")]),t._v(" 自定义事件")]),t._v(" "),v("p",[t._v("​\t\t事件类型  回调函数  谁调用  默认传递的是什么")]),t._v(" "),v("p",[t._v("​\t\t1、事件类型       无数个")]),t._v(" "),v("p",[t._v("​\t\t2、回调函数       自己去定义的")]),t._v(" "),v("p",[t._v("​\t\t3、谁调用        自己去调用  自己使用$emit触发调用的")]),t._v(" "),v("p",[t._v("​\t\t4、默认传递的是什么   默认传递的是自己给的参数 （有就有，没有就没有undefined）")]),t._v(" "),v("p",[t._v("​")]),t._v(" "),v("p",[t._v("​\t\tthis.$emit('haha',10)")]),t._v(" "),v("p",[t._v("​\t原生dom事件在html标签和组件标签上的区别  （Event1组件测试）")]),t._v(" "),v("p",[t._v("​\t\t在html标签上添加就是原生的dom事件")]),t._v(" "),v("p",[t._v("​\t\t在组件标签上添加就是自定义事件，想成为原生的事件得添加修饰符.native,就是把原生dom事件添加到组件根元素上\t(事件委派了)")]),t._v(" "),v("p",[t._v("​\tvue自定义的事件在html标签和组件标签上的区别 （Event2组件测试）")]),t._v(" "),v("p",[t._v("​\t\t在html标签上添加自定义事件无意义，所以自定义事件是给组件标签添加的")]),t._v(" "),v("p",[t._v("​\t\t添加给组件标签：事件名可以任意，也可以和原生的dom事件名相同，但是在组件标签身上即使添加原生dom事件也是自定义的")]),t._v(" "),v("p",[t._v("​")]),t._v(" "),v("h3",{attrs:{id:"_4、全局事件总线-三"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4、全局事件总线-三"}},[t._v("#")]),t._v(" 4、全局事件总线（三）")]),t._v(" "),v("p",[t._v("​\t组件之间通信的一种方式")]),t._v(" "),v("p",[t._v("​")]),t._v(" "),v("p",[t._v("​\t所有场合（所有组件之通信）")]),t._v(" "),v("p",[t._v("​\t全局事件总线的角色标准")]),t._v(" "),v("p",[t._v("​\t本质是一个对象，这个对象有两个要求：")]),t._v(" "),v("p",[t._v("​\t1、所有的组件对象都可以看到它")]),t._v(" "),v("p",[t._v("​\t2、可以使用$on和$emit方法")]),t._v(" "),v("p",[t._v("​")]),t._v(" "),v("p",[t._v("​\t怎么添加事件总线")]),t._v(" "),v("p",[t._v("​\t1、安装总线（越早越好，一本我们在beforeCreate时就安装）")]),t._v(" "),v("p",[t._v("​\t2、在接收数据的组件对象当中  获取总线给总线绑定自定义事件  this.$bus.$on")]),t._v(" "),v("p",[t._v("​\t3、在发送数据的组件对象当中  获取总线触发总线身上绑定的自定义事件  this.$bus.$emit")]),t._v(" "),v("p",[t._v("​")]),t._v(" "),v("h3",{attrs:{id:"_5、v-model-深入-四"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5、v-model-深入-四"}},[t._v("#")]),t._v(" 5、v-model 深入（四）")]),t._v(" "),v("p",[t._v("​\telement-ui表单相关项都使用到了v-model")]),t._v(" "),v("p",[t._v("​\t官方网站也提出了怎么去使用")]),t._v(" "),v("p",[t._v("​")]),t._v(" "),v("p",[t._v("​\t1、html input v-model的本质")]),t._v(" "),v("p",[t._v("​\t\t:value = “data”  //读取数据")]),t._v(" "),v("p",[t._v('​\t\t@input = "data = $event.target.value"  //写数据')]),t._v(" "),v("p",[t._v("​")]),t._v(" "),v("p",[t._v("​\t2、组件标签上 v-model本质")]),t._v(" "),v("p",[t._v('​\t\t:value = "data"  父组件传递属性给子组件，子组件需要接受')]),t._v(" "),v("p",[t._v('​\t\t@input = "data = $event" //父组件当中给子组件添加的自定义事件')]),t._v(" "),v("p",[t._v("​\t\t数据在父组件当中")]),t._v(" "),v("p",[t._v("​")]),t._v(" "),v("p",[t._v("​\t\t子组件当中必须这样写")]),t._v(" "),v("p",[t._v("​\t\t先接受props:['value']")]),t._v(" "),v("p",[t._v("​")]),t._v(" "),v("p",[t._v("​\t\t子组件表单类元素")]),t._v(" "),v("p",[t._v("​")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('\t：value = "value"\n\n​\t@input = "$emit(\'input\',$event.target.value)"\n')])])]),v("p",[t._v("​")]),t._v(" "),v("p",[t._v("​\t干了两件事")]),t._v(" "),v("p",[t._v("​\t\t先显示数据")]),t._v(" "),v("p",[t._v("​\t\t再绑定修改数据的事件")]),t._v(" "),v("p",[t._v("​\t\t只不过在html和组件标签上绑定的@input事件不同  一个是原生的 一个是自定义的事件")]),t._v(" "),v("p",[t._v("​\t实现父子组件双向数据同步问题")]),t._v(" "),v("p",[t._v("​\t1、把父组件的数据，通过props传递给子组件；")]),t._v(" "),v("p",[t._v("​\t2、子组件声明接收属性，就可以读取value值进行使用；")]),t._v(" "),v("p",[t._v("​\t3、父组件给子组件绑定input事件，事件触发后，父组件把接收到子组件修改的数据，拿到修改自己的数据；")]),t._v(" "),v("p",[t._v("​\t4、子组件内部，在适当的时候，触发自定义事件，传递数据")]),t._v(" "),v("p",[t._v("​\t5、父组件数据变化，value会重新传递给子组件，子组件跟着修改")]),t._v(" "),v("p",[t._v("​\t源码查看element-ui的input是不是使用了")]),t._v(" "),v("p",[t._v("​\t本质上还是自定义事件和props组合")]),t._v(" "),v("p",[t._v("​")]),t._v(" "),v("h3",{attrs:{id:"_6、sync-属性修饰符-五"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6、sync-属性修饰符-五"}},[t._v("#")]),t._v(" 6、sync 属性修饰符（五）")]),t._v(" "),v("p",[t._v("​")]),t._v(" "),v("p",[t._v("​\t实现父子组件双向数据同步问题")]),t._v(" "),v("p",[t._v("​\t和 v-model 实现效果几乎一样")]),t._v(" "),v("p",[t._v("​\t区别：约定成俗：")]),t._v(" "),v("p",[t._v("​\tv-model一般用于带表单项的组件")]),t._v(" "),v("p",[t._v("​\tsync属性修饰符一般用于不带表单项的组件")]),t._v(" "),v("p",[t._v("​")]),t._v(" "),v("p",[t._v("​\t父组件给子组件属性传递数据后面添加.sync")]),t._v(" "),v("p",[t._v('​\t子组件修改数据 需要分发事件@click = $emit("update:属性名",要更新的数据)')]),t._v(" "),v("p",[t._v("​\t本质上还是自定义事件和props组合")]),t._v(" "),v("p",[t._v("​\t子组件内部不能直接修改父组件传递过来的数据，否则警告")]),t._v(" "),v("p",[t._v("​\t如果可以修改数据，无法知道是谁修改的")]),t._v(" "),v("h3",{attrs:{id:"_7、-attrs和-linsteners-六"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7、-attrs和-linsteners-六"}},[t._v("#")]),t._v(" 7、$attrs和$linsteners（六）")]),t._v(" "),v("p",[t._v("​\t本质就是父组件中给 子组件传递的所有属性组成的对象及自定义事件方法组成的对象")]),t._v(" "),v("p",[t._v("​\t$attrs 如果不声明props 那么子组件当中是可以看到  如果声明了哪个属性，那么那个属性在$attrs当中看不到")]),t._v(" "),v("p",[t._v("​\t它会排除 props声明接收的属性 以及class style")]),t._v(" "),v("p",[t._v("​\t可以通过v-bind 一次性把父组件传递过来的属性添加给子组件")]),t._v(" "),v("p",[t._v("​\t可以通过v-on  一次性把父组件传递过来的事件监听添加给子组件")]),t._v(" "),v("p",[t._v("​\t对一个组件进行二次封装")]),t._v(" "),v("p",[t._v("8、element-ui的button添加click事件会触发，添加dblclick就不会触发的问题")]),t._v(" "),v("p",[t._v("​")]),t._v(" "),v("p",[t._v("​\telement-ui的button  子组件内部触发了这个单击事件")]),t._v(" "),v("p",[t._v("​\telement-ui的button  子组件内部没有触发这个双击事件")]),t._v(" "),v("p",[t._v("​\t扩展双击点击触发element-ui button事件，使用原生.native")]),t._v(" "),v("h3",{attrs:{id:"_9、-parent-和-children以及-ref-七"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9、-parent-和-children以及-ref-七"}},[t._v("#")]),t._v(" 9、$parent 和 $children以及$ref（七）")]),t._v(" "),v("p",[t._v("​\t$children：所有子组件对象的数组")]),t._v(" "),v("p",[t._v("​\t$parent：代表父组件对象")]),t._v(" "),v("p",[t._v("​\t父组件当中可以通过$children找到所有的子组件去操作子组件的数据（当然可以找孙子组件）")]),t._v(" "),v("p",[t._v("​\t子组件当中可以通过$parent找到父组件（当然可以继续找爷爷组件）操作父组件的数据")]),t._v(" "),v("p",[t._v("​\t$parent 和 $children用的时候注意")]),t._v(" "),v("h3",{attrs:{id:"_10、扩展-多个组件有部分相同的js代码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10、扩展-多个组件有部分相同的js代码"}},[t._v("#")]),t._v(" 10、扩展： 多个组件有部分相同的js代码")]),t._v(" "),v("p",[t._v("​\thtml js  css 相同   封装组件")]),t._v(" "),v("p",[t._v("​\t单个组件js代码重复   封装函数")]),t._v(" "),v("p",[t._v("​\t不同的组件js代码重复  封装模块 （混入）")]),t._v(" "),v("p",[t._v("​\t实现组件之间js代码的复用  利用vue的mixin技术  参考官网")]),t._v(" "),v("p",[t._v("​\t比如多个组件的methods里面很多函数都是重复的 那么我们可以定义单独的模块去把这些相同的代码定义到外部")]),t._v(" "),v("div",{staticClass:"language-javascript extra-class"},[v("pre",{pre:!0,attrs:{class:"language-javascript"}},[v("code",[t._v("\t"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" xxxMixin "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n​\t\tmethods"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n​\t\t\t重复的代码写在这\n​\t\t"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n​\t"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),v("h3",{attrs:{id:"_11、作用域插槽-八"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11、作用域插槽-八"}},[t._v("#")]),t._v(" 11、作用域插槽（八）")]),t._v(" "),v("p",[t._v("​\t适用：父子之间")]),t._v(" "),v("p",[t._v("​\t数据是在父组件当中的，数据是要给子组件去展示的（vfor）")]),t._v(" "),v("p",[t._v("​\t展示的过程当中，数据的结构 子组件说了不算，是由父组件决定的")]),t._v(" "),v("p",[t._v("​\t父组件要把需要子组件展示的数据传递给子组件")]),t._v(" "),v("p",[t._v("​\t子组件在展示的过程当中，需要改变结构的数据传回给父组件")]),t._v(" "),v("p",[t._v("​\t父组件再把结果和数据一并传回给子组件")]),t._v(" "),v("h3",{attrs:{id:"_12、vuex-九"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12、vuex-九"}},[t._v("#")]),t._v(" 12、vuex（九）")]),t._v(" "),v("p",[t._v("​")]),t._v(" "),v("p",[t._v("​\t组件之间通讯方式（也是共享状态管理）")]),t._v(" "),v("p",[t._v("​\t4个核心概念")]),t._v(" "),v("p",[t._v("​\tstate \t存放数据")]),t._v(" "),v("p",[t._v("​\tmutations\t\t直接修改数据")]),t._v(" "),v("p",[t._v("​\tactions\t对象，存放的也是方法，两个作用，1、其实是vue和vuex的桥梁 2、提交mutation修改state数据")]),t._v(" "),v("p",[t._v("​\tgetters")]),t._v(" "),v("p",[t._v("​\tmodules //vuex的模块化开发")]),t._v(" "),v("p",[t._v("​\t主要针对state")]),t._v(" "),v("p",[t._v("​\tnamespace //命名空间")]),t._v(" "),v("p",[t._v("​\t什么时候用vuex？")]),t._v(" "),v("p",[t._v("​\t项目复杂的时候，使用vuex，")]),t._v(" "),v("h3",{attrs:{id:"_13、消息的订阅和发布-pubsubjs-十-代码参考基友-说法参考全局事件总线"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13、消息的订阅和发布-pubsubjs-十-代码参考基友-说法参考全局事件总线"}},[t._v("#")]),t._v(" 13、消息的订阅和发布  PubSubJS (十)  代码参考基友   说法参考全局事件总线")]),t._v(" "),v("p",[t._v("​")])])}),[],!1,null,null,null);v.default=a.exports}}]);